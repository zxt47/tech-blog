<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="Frank Zhou的技术博客-A Tech Blog For Frank Zhou" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     Frank Zhou的博客
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/tech-blog/css/style.css">

  
<script src="/tech-blog/js/pace.min.js"></script>


  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/tech-blog/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/tech-blog/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/tech-blog/">Frank Zhou的博客</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-Spring-MVC" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/tech-blog/2020/06/08/Spring-MVC/"
    >Spring MVC</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/tech-blog/2020/06/08/Spring-MVC/" class="article-date">
  <time datetime="2020-06-08T12:14:15.000Z" itemprop="datePublished">2020-06-08</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/tech-blog/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><h2 id="什么是MVC？"><a href="#什么是MVC？" class="headerlink" title="什么是MVC？"></a>什么是MVC？</h2><p>MVC设计模式，一般指MODEL,VIEW,Controller；</p>
<p>首先我们先了解一下这三者的概念。</p>
<p>Model(模型):</p>
<p>数据模型，提供要展示的数据，因此包含数据和行为，可以理解为JavaBean组件(包含数据和行为)，不过现在一般都分离开来：数据层和服务层(行为)。也就是model提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。</p>
<p>View(视图):</p>
<p>负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。</p>
<p>Controller(控制器)：</p>
<p>接收用户请求，委托给模型进行处理(状态改变)，处理完毕后把返回的模型数据返回给视图，由视图负责展示。因此我们可以把控制器理解为一个调度员。</p>
<h2 id="Spring-MVC流程"><a href="#Spring-MVC流程" class="headerlink" title="Spring MVC流程"></a>Spring MVC流程</h2><p>ServletContextListener和ContextLoaderListener</p>
<h2 id="Filter和Interceptor"><a href="#Filter和Interceptor" class="headerlink" title="Filter和Interceptor"></a>Filter和Interceptor</h2><p>Spring中是没有Filter的概念的，Spring中只有Interceptor的概念，类似org.aopalliance.intercept.Interceptor这一类中的介绍，但是Spring MVC中实现这一类型的则是来自于org.springframework.web.servlet.HandlerInterceptor；</p>
<p>参考资料</p>
<p><a href="https://www.jianshu.com/p/3c94d7e76998" target="_blank" rel="noopener">https://www.jianshu.com/p/3c94d7e76998</a></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tech-blog/tags/Spring-MVC/" rel="tag">Spring MVC</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-MySQL-Basic" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/tech-blog/2020/06/08/MySQL-Basic/"
    >MySQL Basic</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/tech-blog/2020/06/08/MySQL-Basic/" class="article-date">
  <time datetime="2020-06-08T07:50:20.000Z" itemprop="datePublished">2020-06-08</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/tech-blog/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h1><h2 id="MySQL中一条SQL语句是怎样运行的？"><a href="#MySQL中一条SQL语句是怎样运行的？" class="headerlink" title="MySQL中一条SQL语句是怎样运行的？"></a>MySQL中一条SQL语句是怎样运行的？</h2><p>访问客户端通过连接器执行sql</p>
<p>分析器解析SQL语句后分解为指令集</p>
<p>注意此项在高版本的MySQL会被优化-先查询缓存，命中就直接返回结果</p>
<p>非查询或未命中，进入优化器产生执行计划并选择索引</p>
<p>执行器执行后返回结果</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h3 id="解析执行计划"><a href="#解析执行计划" class="headerlink" title="解析执行计划"></a>解析执行计划</h3>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tech-blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-客户端cache" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/tech-blog/2020/06/07/%E5%AE%A2%E6%88%B7%E7%AB%AFcache/"
    >客户端cache</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/tech-blog/2020/06/07/%E5%AE%A2%E6%88%B7%E7%AB%AFcache/" class="article-date">
  <time datetime="2020-06-07T03:28:33.000Z" itemprop="datePublished">2020-06-07</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/tech-blog/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="客户端本地缓存"><a href="#客户端本地缓存" class="headerlink" title="客户端本地缓存"></a>客户端本地缓存</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>一般在现在的开发过程中，除去Redis这种集中式缓存集群之外，作为服务端提供者也可以使用本地JVM缓存来进行多级缓存的设置和单机服务端缓存的设置。</p>
<h2 id="常用技术选型"><a href="#常用技术选型" class="headerlink" title="常用技术选型"></a>常用技术选型</h2><p>JDK中的ConcurrentMap，Ehcache，Guava Cache，除此之外，Spring Cache作为缓存服务提供标准的一个标准接口</p>
<h3 id="传统同步Map"><a href="#传统同步Map" class="headerlink" title="传统同步Map"></a>传统同步Map</h3><p>传统同步Map保证了线程安全性，但是没有淘汰策略，也没有内存管理的能力，而且也没有虚拟机重启时恢复能力。所以除非对于一致性完全不高，并且容量较低的情况下我们才是用传统同步Map。</p>
<h3 id="Ehcache"><a href="#Ehcache" class="headerlink" title="Ehcache"></a>Ehcache</h3><ul>
<li>多级缓存策略</li>
<li>缓存数据可以持久化内存</li>
<li>缓存数据在虚拟机重启的过程中从磁盘写入内存</li>
<li>可以支持事件监听和报警</li>
<li>多机可以通过RMI或者接口的形式构成缓存集群</li>
</ul>
<h3 id="Guava-Cache"><a href="#Guava-Cache" class="headerlink" title="Guava Cache"></a>Guava Cache</h3><h3 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h3><h2 id="JSR107缓存规范"><a href="#JSR107缓存规范" class="headerlink" title="JSR107缓存规范"></a>JSR107缓存规范</h2><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://q.cnblogs.com/q/111220/" target="_blank" rel="noopener">Spring Cache中的常见问题</a></p>
<p><a href="https://blog.csdn.net/weixin_44488164/article/details/89479170" target="_blank" rel="noopener">Spring Cache中如何使用多个参数作为缓存的KEY</a></p>
<p><a href="https://blog.csdn.net/fireofjava/article/details/48913335" target="_blank" rel="noopener">Spring EL表达式生成缓存中的Key</a></p>
<p><a href="https://blog.csdn.net/xiewenfeng520/article/details/84864120" target="_blank" rel="noopener">Spring Cache注解的基本介绍</a></p>
<p><a href="https://www.cnblogs.com/MagicAsa/p/10756331.html" target="_blank" rel="noopener">JSR107规范博客</a></p>
<p><a href="https://www.jcp.org/en/jsr/detail?id=107" target="_blank" rel="noopener">JSR107官方特性</a></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tech-blog/tags/%E7%BC%93%E5%AD%98/" rel="tag">缓存</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Spring-Framework-Bean-初步" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/tech-blog/2020/06/05/Spring-Framework-Bean-%E5%88%9D%E6%AD%A5/"
    >Spring Framework Bean 初步</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/tech-blog/2020/06/05/Spring-Framework-Bean-%E5%88%9D%E6%AD%A5/" class="article-date">
  <time datetime="2020-06-05T00:25:14.000Z" itemprop="datePublished">2020-06-05</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/tech-blog/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="Spring框架中启动过程-Bean启动过程"><a href="#Spring框架中启动过程-Bean启动过程" class="headerlink" title="Spring框架中启动过程-Bean启动过程"></a>Spring框架中启动过程-Bean启动过程</h1><h2 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.annotation.AnnotatedBeanDefinitionReader</span><br><span class="line">org.springframework.context.annotation.ClassPathBeanDefinitionScanner</span><br></pre></td></tr></table></figure>

<h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.support.DefaultListableBeanFactory</span><br></pre></td></tr></table></figure>

<h2 id="SPI扩展"><a href="#SPI扩展" class="headerlink" title="SPI扩展"></a>SPI扩展</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor</span><br></pre></td></tr></table></figure>

<h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.util.ReflectionUtils</span><br></pre></td></tr></table></figure>







<p>附录：一个Spring容器启动的完整DEBUG日志</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tech-blog/tags/Spring/" rel="tag">Spring</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-HTTP性能测试工具" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/tech-blog/2020/05/24/HTTP%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"
    >HTTP性能测试工具</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/tech-blog/2020/05/24/HTTP%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/" class="article-date">
  <time datetime="2020-05-24T02:10:16.000Z" itemprop="datePublished">2020-05-24</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/tech-blog/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="HTTP性能测试工具"><a href="#HTTP性能测试工具" class="headerlink" title="HTTP性能测试工具"></a>HTTP性能测试工具</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>什么是HTTP性能测试工具，包含类似于ab(Apache BenchMark工具)，Wrk（只能在Unix环境上使用）这些可以进行性能测试的工具；不会像LoadRunner或者Jmeter那种较重的性能测试工具，ab只需要进行简单的配置就可以直接使用；</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>ab工具放在Apache HTTP Server安装包的bin目录下，所以要先安装Apache HTTP Server（以Windows系统为例）。</p>
<p>到Apache HTTP Server官网下载页面（<a href="https://link.jianshu.com?t=http://httpd.apache.org/download.cgi#apache24" target="_blank" rel="noopener">点击链接</a>），目前最新的版本不提供Windows系统下的安装包，所以用第三方的安装包。点击下图链接：</p>
<p>选择进入到Apache的Haus，下载之后配置环境变量就可以直接使用了；</p>
<h2 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h2><p><img src="E:%5Ctech-blog%5Csource_posts%5CHTTP%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%5Cimage-20200524101537116.png" alt="image-20200524101537116"></p>
<p>参考文档</p>
<p><a href="https://www.jianshu.com/p/e3793ae91a62" target="_blank" rel="noopener">https://www.jianshu.com/p/e3793ae91a62</a></p>
<p><a href="http://httpd.apache.org/docs/current/programs/ab.html" target="_blank" rel="noopener">http://httpd.apache.org/docs/current/programs/ab.html</a></p>
<p><a href="https://www.cnblogs.com/jave1ove/p/5486427.html" target="_blank" rel="noopener">https://www.cnblogs.com/jave1ove/p/5486427.html</a></p>
<p><a href="https://www.cnblogs.com/savorboard/p/wrk.html" target="_blank" rel="noopener">https://www.cnblogs.com/savorboard/p/wrk.html</a></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tech-blog/tags/HTTP/" rel="tag">HTTP</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="bean-Validation" class="article article-type-bean" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/tech-blog/2020/05/19/Validation/"
    >Validation</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/tech-blog/2020/05/19/Validation/" class="article-date">
  <time datetime="2020-05-19T13:12:39.000Z" itemprop="datePublished">2020-05-19</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="Bean-Validate-API"><a href="#Bean-Validate-API" class="headerlink" title="Bean Validate API"></a>Bean Validate API</h1><p>在接口开发中有一种较为方便的对Bean参数进行合法性校验的操作。在Java规范中是作为JSR303和JSR380规范存在的；</p>
<p>参考文档</p>
<p><a href="https://www.cnblogs.com/didispace/p/11633661.html" target="_blank" rel="noopener">技术博客</a></p>
<p><a href="https://blog.csdn.net/f641385712/article/details/97968775" target="_blank" rel="noopener">https://blog.csdn.net/f641385712/article/details/97968775</a></p>
<p><a href="https://blog.csdn.net/mzh_cn/article/details/80637015?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/mzh_cn/article/details/80637015?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></p>
<p><a href="https://blog.csdn.net/u013815546/article/details/77248003?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/u013815546/article/details/77248003?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase</a></p>
<p><a href="https://blog.csdn.net/f641385712/article/details/97270786" target="_blank" rel="noopener">https://blog.csdn.net/f641385712/article/details/97270786</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=2247484396&amp;idx=1&amp;sn=f6b73fbb6dd2d107e5b1bfde16cd6754&amp;chksm=eb470208dc308b1e32fc37b067e74d4a83857e2e966653bd11001726e08b860e9b8823b8029f&amp;scene=126&amp;sessionid=1589765413&amp;key=d0a1cff4a53ee366b6a3b9db4463a81c57f0a31df7c674d69da5c1e68fd9ac41541c57f4ff9aad6d561ed132b7f24e97f92e1a2561906b3375ca9013ffb78ef22da17f8524ed188eb9250016b78895d8&amp;ascene=1&amp;uin=MjIwMjY1NzQ2Mw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=AfSw7wIOssnlM2H1lkDUY0M%3D&amp;pass_ticket=WapZN1mC7IMHiY8PyF4qiSKWo9tWf593g%2F80CUEj2tevTdAHcfeQ97NwcQJIJWww" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=2247484396&amp;idx=1&amp;sn=f6b73fbb6dd2d107e5b1bfde16cd6754&amp;chksm=eb470208dc308b1e32fc37b067e74d4a83857e2e966653bd11001726e08b860e9b8823b8029f&amp;scene=126&amp;sessionid=1589765413&amp;key=d0a1cff4a53ee366b6a3b9db4463a81c57f0a31df7c674d69da5c1e68fd9ac41541c57f4ff9aad6d561ed132b7f24e97f92e1a2561906b3375ca9013ffb78ef22da17f8524ed188eb9250016b78895d8&amp;ascene=1&amp;uin=MjIwMjY1NzQ2Mw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=AfSw7wIOssnlM2H1lkDUY0M%3D&amp;pass_ticket=WapZN1mC7IMHiY8PyF4qiSKWo9tWf593g%2F80CUEj2tevTdAHcfeQ97NwcQJIJWww</a></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-ASCII到UTF-8" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/tech-blog/2020/05/04/ASCII%E5%88%B0UTF-8/"
    >ASCII到UTF-8</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/tech-blog/2020/05/04/ASCII%E5%88%B0UTF-8/" class="article-date">
  <time datetime="2020-05-04T03:46:29.953Z" itemprop="datePublished">2020-05-04</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="ASCII到UTF-8"><a href="#ASCII到UTF-8" class="headerlink" title="ASCII到UTF-8"></a>ASCII到UTF-8</h1><table>
<thead>
<tr>
<th>Bin(二进制)</th>
<th>Oct(八进制)</th>
<th>Dec(十进制)</th>
<th>Hex(十六进制)</th>
<th>缩写/字符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>0000 0000</td>
<td>00</td>
<td>0</td>
<td>0x00</td>
<td>NUL(null)</td>
<td>空字符</td>
</tr>
<tr>
<td>0000 0001</td>
<td>01</td>
<td>1</td>
<td>0x01</td>
<td>SOH(start of headline)</td>
<td>标题开始</td>
</tr>
<tr>
<td>0000 0010</td>
<td>02</td>
<td>2</td>
<td>0x02</td>
<td>STX (start of text)</td>
<td>正文开始</td>
</tr>
<tr>
<td>0000 0011</td>
<td>03</td>
<td>3</td>
<td>0x03</td>
<td>ETX (end of text)</td>
<td>正文结束</td>
</tr>
<tr>
<td>0000 0100</td>
<td>04</td>
<td>4</td>
<td>0x04</td>
<td>EOT (end of transmission)</td>
<td>传输结束</td>
</tr>
<tr>
<td>0000 0101</td>
<td>05</td>
<td>5</td>
<td>0x05</td>
<td>ENQ (enquiry)</td>
<td>请求</td>
</tr>
<tr>
<td>0000 0110</td>
<td>06</td>
<td>6</td>
<td>0x06</td>
<td>ACK (acknowledge)</td>
<td>收到通知</td>
</tr>
<tr>
<td>0000 0111</td>
<td>07</td>
<td>7</td>
<td>0x07</td>
<td>BEL (bell)</td>
<td>响铃</td>
</tr>
<tr>
<td>0000 1000</td>
<td>010</td>
<td>8</td>
<td>0x08</td>
<td>BS (backspace)</td>
<td>退格</td>
</tr>
<tr>
<td>0000 1001</td>
<td>011</td>
<td>9</td>
<td>0x09</td>
<td>HT (horizontal tab)</td>
<td>水平制表符</td>
</tr>
<tr>
<td>0000 1010</td>
<td>012</td>
<td>10</td>
<td>0x0A</td>
<td>LF (NL line feed, new line)</td>
<td>换行键</td>
</tr>
<tr>
<td>0000 1011</td>
<td>013</td>
<td>11</td>
<td>0x0B</td>
<td>VT (vertical tab)</td>
<td>垂直制表符</td>
</tr>
<tr>
<td>0000 1100</td>
<td>014</td>
<td>12</td>
<td>0x0C</td>
<td>FF (NP form feed, new page)</td>
<td>换页键</td>
</tr>
<tr>
<td>0000 1101</td>
<td>015</td>
<td>13</td>
<td>0x0D</td>
<td>CR (carriage return)</td>
<td>回车键</td>
</tr>
<tr>
<td>0000 1110</td>
<td>016</td>
<td>14</td>
<td>0x0E</td>
<td>SO (shift out)</td>
<td>不用切换</td>
</tr>
<tr>
<td>0000 1111</td>
<td>017</td>
<td>15</td>
<td>0x0F</td>
<td>SI (shift in)</td>
<td>启用切换</td>
</tr>
<tr>
<td>0001 0000</td>
<td>020</td>
<td>16</td>
<td>0x10</td>
<td>DLE (data link escape)</td>
<td>数据链路转义</td>
</tr>
<tr>
<td>0001 0001</td>
<td>021</td>
<td>17</td>
<td>0x11</td>
<td>DC1 (device control 1)</td>
<td>设备控制1</td>
</tr>
<tr>
<td>0001 0010</td>
<td>022</td>
<td>18</td>
<td>0x12</td>
<td>DC2 (device control 2)</td>
<td>设备控制2</td>
</tr>
<tr>
<td>0001 0011</td>
<td>023</td>
<td>19</td>
<td>0x13</td>
<td>DC3 (device control 3)</td>
<td>设备控制3</td>
</tr>
<tr>
<td>0001 0100</td>
<td>024</td>
<td>20</td>
<td>0x14</td>
<td>DC4 (device control 4)</td>
<td>设备控制4</td>
</tr>
<tr>
<td>0001 0101</td>
<td>025</td>
<td>21</td>
<td>0x15</td>
<td>NAK (negative acknowledge)</td>
<td>拒绝接收</td>
</tr>
<tr>
<td>0001 0110</td>
<td>026</td>
<td>22</td>
<td>0x16</td>
<td>SYN (synchronous idle)</td>
<td>同步空闲</td>
</tr>
<tr>
<td>0001 0111</td>
<td>027</td>
<td>23</td>
<td>0x17</td>
<td>ETB (end of trans. block)</td>
<td>结束传输块</td>
</tr>
<tr>
<td>0001 1000</td>
<td>030</td>
<td>24</td>
<td>0x18</td>
<td>CAN (cancel)</td>
<td>取消</td>
</tr>
<tr>
<td>0001 1001</td>
<td>031</td>
<td>25</td>
<td>0x19</td>
<td>EM (end of medium)</td>
<td>媒介结束</td>
</tr>
<tr>
<td>0001 1010</td>
<td>032</td>
<td>26</td>
<td>0x1A</td>
<td>SUB (substitute)</td>
<td>代替</td>
</tr>
<tr>
<td>0001 1011</td>
<td>033</td>
<td>27</td>
<td>0x1B</td>
<td>ESC (escape)</td>
<td>换码(溢出)</td>
</tr>
<tr>
<td>0001 1100</td>
<td>034</td>
<td>28</td>
<td>0x1C</td>
<td>FS (file separator)</td>
<td>文件分隔符</td>
</tr>
<tr>
<td>0001 1101</td>
<td>035</td>
<td>29</td>
<td>0x1D</td>
<td>GS (group separator)</td>
<td>分组符</td>
</tr>
<tr>
<td>0001 1110</td>
<td>036</td>
<td>30</td>
<td>0x1E</td>
<td>RS (record separator)</td>
<td>记录分隔符</td>
</tr>
<tr>
<td>0001 1111</td>
<td>037</td>
<td>31</td>
<td>0x1F</td>
<td>US (unit separator)</td>
<td>单元分隔符</td>
</tr>
<tr>
<td>0010 0000</td>
<td>040</td>
<td>32</td>
<td>0x20</td>
<td>(space)</td>
<td>空格</td>
</tr>
<tr>
<td>0010 0001</td>
<td>041</td>
<td>33</td>
<td>0x21</td>
<td>!</td>
<td>叹号</td>
</tr>
<tr>
<td>0010 0010</td>
<td>042</td>
<td>34</td>
<td>0x22</td>
<td>“</td>
<td>双引号</td>
</tr>
<tr>
<td>0010 0011</td>
<td>043</td>
<td>35</td>
<td>0x23</td>
<td>#</td>
<td>井号</td>
</tr>
<tr>
<td>0010 0100</td>
<td>044</td>
<td>36</td>
<td>0x24</td>
<td>$</td>
<td>美元符</td>
</tr>
<tr>
<td>0010 0101</td>
<td>045</td>
<td>37</td>
<td>0x25</td>
<td>%</td>
<td>百分号</td>
</tr>
<tr>
<td>0010 0110</td>
<td>046</td>
<td>38</td>
<td>0x26</td>
<td>&amp;</td>
<td>和号</td>
</tr>
<tr>
<td>0010 0111</td>
<td>047</td>
<td>39</td>
<td>0x27</td>
<td>‘</td>
<td>闭单引号</td>
</tr>
<tr>
<td>0010 1000</td>
<td>050</td>
<td>40</td>
<td>0x28</td>
<td>(</td>
<td>开括号</td>
</tr>
<tr>
<td>0010 1001</td>
<td>051</td>
<td>41</td>
<td>0x29</td>
<td>)</td>
<td>闭括号</td>
</tr>
<tr>
<td>0010 1010</td>
<td>052</td>
<td>42</td>
<td>0x2A</td>
<td>*</td>
<td>星号</td>
</tr>
<tr>
<td>0010 1011</td>
<td>053</td>
<td>43</td>
<td>0x2B</td>
<td>+</td>
<td>加号</td>
</tr>
<tr>
<td>0010 1100</td>
<td>054</td>
<td>44</td>
<td>0x2C</td>
<td>,</td>
<td>逗号</td>
</tr>
<tr>
<td>0010 1101</td>
<td>055</td>
<td>45</td>
<td>0x2D</td>
<td>-</td>
<td>减号/破折号</td>
</tr>
<tr>
<td>0010 1110</td>
<td>056</td>
<td>46</td>
<td>0x2E</td>
<td>.</td>
<td>句号</td>
</tr>
<tr>
<td>0010 1111</td>
<td>057</td>
<td>47</td>
<td>0x2F</td>
<td>/</td>
<td>斜杠</td>
</tr>
<tr>
<td>0011 0000</td>
<td>060</td>
<td>48</td>
<td>0x30</td>
<td>0</td>
<td>字符0</td>
</tr>
<tr>
<td>0011 0001</td>
<td>061</td>
<td>49</td>
<td>0x31</td>
<td>1</td>
<td>字符1</td>
</tr>
<tr>
<td>0011 0010</td>
<td>062</td>
<td>50</td>
<td>0x32</td>
<td>2</td>
<td>字符2</td>
</tr>
<tr>
<td>0011 0011</td>
<td>063</td>
<td>51</td>
<td>0x33</td>
<td>3</td>
<td>字符3</td>
</tr>
<tr>
<td>0011 0100</td>
<td>064</td>
<td>52</td>
<td>0x34</td>
<td>4</td>
<td>字符4</td>
</tr>
<tr>
<td>0011 0101</td>
<td>065</td>
<td>53</td>
<td>0x35</td>
<td>5</td>
<td>字符5</td>
</tr>
<tr>
<td>0011 0110</td>
<td>066</td>
<td>54</td>
<td>0x36</td>
<td>6</td>
<td>字符6</td>
</tr>
<tr>
<td>0011 0111</td>
<td>067</td>
<td>55</td>
<td>0x37</td>
<td>7</td>
<td>字符7</td>
</tr>
<tr>
<td>0011 1000</td>
<td>070</td>
<td>56</td>
<td>0x38</td>
<td>8</td>
<td>字符8</td>
</tr>
<tr>
<td>0011 1001</td>
<td>071</td>
<td>57</td>
<td>0x39</td>
<td>9</td>
<td>字符9</td>
</tr>
<tr>
<td>0011 1010</td>
<td>072</td>
<td>58</td>
<td>0x3A</td>
<td>:</td>
<td>冒号</td>
</tr>
<tr>
<td>0011 1011</td>
<td>073</td>
<td>59</td>
<td>0x3B</td>
<td>;</td>
<td>分号</td>
</tr>
<tr>
<td>0011 1100</td>
<td>074</td>
<td>60</td>
<td>0x3C</td>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>0011 1101</td>
<td>075</td>
<td>61</td>
<td>0x3D</td>
<td>=</td>
<td>等号</td>
</tr>
<tr>
<td>0011 1110</td>
<td>076</td>
<td>62</td>
<td>0x3E</td>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>0011 1111</td>
<td>077</td>
<td>63</td>
<td>0x3F</td>
<td>?</td>
<td>问号</td>
</tr>
<tr>
<td>0100 0000</td>
<td>0100</td>
<td>64</td>
<td>0x40</td>
<td>@</td>
<td>电子邮件符号</td>
</tr>
<tr>
<td>0100 0001</td>
<td>0101</td>
<td>65</td>
<td>0x41</td>
<td>A</td>
<td>大写字母A</td>
</tr>
<tr>
<td>0100 0010</td>
<td>0102</td>
<td>66</td>
<td>0x42</td>
<td>B</td>
<td>大写字母B</td>
</tr>
<tr>
<td>0100 0011</td>
<td>0103</td>
<td>67</td>
<td>0x43</td>
<td>C</td>
<td>大写字母C</td>
</tr>
<tr>
<td>0100 0100</td>
<td>0104</td>
<td>68</td>
<td>0x44</td>
<td>D</td>
<td>大写字母D</td>
</tr>
<tr>
<td>0100 0101</td>
<td>0105</td>
<td>69</td>
<td>0x45</td>
<td>E</td>
<td>大写字母E</td>
</tr>
<tr>
<td>0100 0110</td>
<td>0106</td>
<td>70</td>
<td>0x46</td>
<td>F</td>
<td>大写字母F</td>
</tr>
<tr>
<td>0100 0111</td>
<td>0107</td>
<td>71</td>
<td>0x47</td>
<td>G</td>
<td>大写字母G</td>
</tr>
<tr>
<td>0100 1000</td>
<td>0110</td>
<td>72</td>
<td>0x48</td>
<td>H</td>
<td>大写字母H</td>
</tr>
<tr>
<td>0100 1001</td>
<td>0111</td>
<td>73</td>
<td>0x49</td>
<td>I</td>
<td>大写字母I</td>
</tr>
<tr>
<td>01001010</td>
<td>0112</td>
<td>74</td>
<td>0x4A</td>
<td>J</td>
<td>大写字母J</td>
</tr>
<tr>
<td>0100 1011</td>
<td>0113</td>
<td>75</td>
<td>0x4B</td>
<td>K</td>
<td>大写字母K</td>
</tr>
<tr>
<td>0100 1100</td>
<td>0114</td>
<td>76</td>
<td>0x4C</td>
<td>L</td>
<td>大写字母L</td>
</tr>
<tr>
<td>0100 1101</td>
<td>0115</td>
<td>77</td>
<td>0x4D</td>
<td>M</td>
<td>大写字母M</td>
</tr>
<tr>
<td>0100 1110</td>
<td>0116</td>
<td>78</td>
<td>0x4E</td>
<td>N</td>
<td>大写字母N</td>
</tr>
<tr>
<td>0100 1111</td>
<td>0117</td>
<td>79</td>
<td>0x4F</td>
<td>O</td>
<td>大写字母O</td>
</tr>
<tr>
<td>0101 0000</td>
<td>0120</td>
<td>80</td>
<td>0x50</td>
<td>P</td>
<td>大写字母P</td>
</tr>
<tr>
<td>0101 0001</td>
<td>0121</td>
<td>81</td>
<td>0x51</td>
<td>Q</td>
<td>大写字母Q</td>
</tr>
<tr>
<td>0101 0010</td>
<td>0122</td>
<td>82</td>
<td>0x52</td>
<td>R</td>
<td>大写字母R</td>
</tr>
<tr>
<td>0101 0011</td>
<td>0123</td>
<td>83</td>
<td>0x53</td>
<td>S</td>
<td>大写字母S</td>
</tr>
<tr>
<td>0101 0100</td>
<td>0124</td>
<td>84</td>
<td>0x54</td>
<td>T</td>
<td>大写字母T</td>
</tr>
<tr>
<td>0101 0101</td>
<td>0125</td>
<td>85</td>
<td>0x55</td>
<td>U</td>
<td>大写字母U</td>
</tr>
<tr>
<td>0101 0110</td>
<td>0126</td>
<td>86</td>
<td>0x56</td>
<td>V</td>
<td>大写字母V</td>
</tr>
<tr>
<td>0101 0111</td>
<td>0127</td>
<td>87</td>
<td>0x57</td>
<td>W</td>
<td>大写字母W</td>
</tr>
<tr>
<td>0101 1000</td>
<td>0130</td>
<td>88</td>
<td>0x58</td>
<td>X</td>
<td>大写字母X</td>
</tr>
<tr>
<td>0101 1001</td>
<td>0131</td>
<td>89</td>
<td>0x59</td>
<td>Y</td>
<td>大写字母Y</td>
</tr>
<tr>
<td>0101 1010</td>
<td>0132</td>
<td>90</td>
<td>0x5A</td>
<td>Z</td>
<td>大写字母Z</td>
</tr>
<tr>
<td>0101 1011</td>
<td>0133</td>
<td>91</td>
<td>0x5B</td>
<td>[</td>
<td>开方括号</td>
</tr>
<tr>
<td>0101 1100</td>
<td>0134</td>
<td>92</td>
<td>0x5C</td>
<td>\</td>
<td>反斜杠</td>
</tr>
<tr>
<td>0101 1101</td>
<td>0135</td>
<td>93</td>
<td>0x5D</td>
<td>]</td>
<td>闭方括号</td>
</tr>
<tr>
<td>0101 1110</td>
<td>0136</td>
<td>94</td>
<td>0x5E</td>
<td>^</td>
<td>脱字符</td>
</tr>
<tr>
<td>0101 1111</td>
<td>0137</td>
<td>95</td>
<td>0x5F</td>
<td>_</td>
<td>下划线</td>
</tr>
<tr>
<td>0110 0000</td>
<td>0140</td>
<td>96</td>
<td>0x60</td>
<td>`</td>
<td>开单引号</td>
</tr>
<tr>
<td>0110 0001</td>
<td>0141</td>
<td>97</td>
<td>0x61</td>
<td>a</td>
<td>小写字母a</td>
</tr>
<tr>
<td>0110 0010</td>
<td>0142</td>
<td>98</td>
<td>0x62</td>
<td>b</td>
<td>小写字母b</td>
</tr>
<tr>
<td>0110 0011</td>
<td>0143</td>
<td>99</td>
<td>0x63</td>
<td>c</td>
<td>小写字母c</td>
</tr>
<tr>
<td>0110 0100</td>
<td>0144</td>
<td>100</td>
<td>0x64</td>
<td>d</td>
<td>小写字母d</td>
</tr>
<tr>
<td>0110 0101</td>
<td>0145</td>
<td>101</td>
<td>0x65</td>
<td>e</td>
<td>小写字母e</td>
</tr>
<tr>
<td>0110 0110</td>
<td>0146</td>
<td>102</td>
<td>0x66</td>
<td>f</td>
<td>小写字母f</td>
</tr>
<tr>
<td>0110 0111</td>
<td>0147</td>
<td>103</td>
<td>0x67</td>
<td>g</td>
<td>小写字母g</td>
</tr>
<tr>
<td>0110 1000</td>
<td>0150</td>
<td>104</td>
<td>0x68</td>
<td>h</td>
<td>小写字母h</td>
</tr>
<tr>
<td>0110 1001</td>
<td>0151</td>
<td>105</td>
<td>0x69</td>
<td>i</td>
<td>小写字母i</td>
</tr>
<tr>
<td>0110 1010</td>
<td>0152</td>
<td>106</td>
<td>0x6A</td>
<td>j</td>
<td>小写字母j</td>
</tr>
<tr>
<td>0110 1011</td>
<td>0153</td>
<td>107</td>
<td>0x6B</td>
<td>k</td>
<td>小写字母k</td>
</tr>
<tr>
<td>0110 1100</td>
<td>0154</td>
<td>108</td>
<td>0x6C</td>
<td>l</td>
<td>小写字母l</td>
</tr>
<tr>
<td>0110 1101</td>
<td>0155</td>
<td>109</td>
<td>0x6D</td>
<td>m</td>
<td>小写字母m</td>
</tr>
<tr>
<td>0110 1110</td>
<td>0156</td>
<td>110</td>
<td>0x6E</td>
<td>n</td>
<td>小写字母n</td>
</tr>
<tr>
<td>0110 1111</td>
<td>0157</td>
<td>111</td>
<td>0x6F</td>
<td>o</td>
<td>小写字母o</td>
</tr>
<tr>
<td>0111 0000</td>
<td>0160</td>
<td>112</td>
<td>0x70</td>
<td>p</td>
<td>小写字母p</td>
</tr>
<tr>
<td>0111 0001</td>
<td>0161</td>
<td>113</td>
<td>0x71</td>
<td>q</td>
<td>小写字母q</td>
</tr>
<tr>
<td>0111 0010</td>
<td>0162</td>
<td>114</td>
<td>0x72</td>
<td>r</td>
<td>小写字母r</td>
</tr>
<tr>
<td>0111 0011</td>
<td>0163</td>
<td>115</td>
<td>0x73</td>
<td>s</td>
<td>小写字母s</td>
</tr>
<tr>
<td>0111 0100</td>
<td>0164</td>
<td>116</td>
<td>0x74</td>
<td>t</td>
<td>小写字母t</td>
</tr>
<tr>
<td>0111 0101</td>
<td>0165</td>
<td>117</td>
<td>0x75</td>
<td>u</td>
<td>小写字母u</td>
</tr>
<tr>
<td>0111 0110</td>
<td>0166</td>
<td>118</td>
<td>0x76</td>
<td>v</td>
<td>小写字母v</td>
</tr>
<tr>
<td>0111 0111</td>
<td>0167</td>
<td>119</td>
<td>0x77</td>
<td>w</td>
<td>小写字母w</td>
</tr>
<tr>
<td>0111 1000</td>
<td>0170</td>
<td>120</td>
<td>0x78</td>
<td>x</td>
<td>小写字母x</td>
</tr>
<tr>
<td>0111 1001</td>
<td>0171</td>
<td>121</td>
<td>0x79</td>
<td>y</td>
<td>小写字母y</td>
</tr>
<tr>
<td>0111 1010</td>
<td>0172</td>
<td>122</td>
<td>0x7A</td>
<td>z</td>
<td>小写字母z</td>
</tr>
<tr>
<td>0111 1011</td>
<td>0173</td>
<td>123</td>
<td>0x7B</td>
<td>{</td>
<td>开花括号</td>
</tr>
<tr>
<td>0111 1100</td>
<td>0174</td>
<td>124</td>
<td>0x7C</td>
<td>|</td>
<td>垂线</td>
</tr>
<tr>
<td>0111 1101</td>
<td>0175</td>
<td>125</td>
<td>0x7D</td>
<td>}</td>
<td>闭花括号</td>
</tr>
<tr>
<td>0111 1110</td>
<td>0176</td>
<td>126</td>
<td>0x7E</td>
<td>~</td>
<td>波浪号</td>
</tr>
<tr>
<td>0111 1111</td>
<td>0177</td>
<td>127</td>
<td>0x7F</td>
<td>DEL (delete)</td>
<td>删除</td>
</tr>
</tbody></table>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Java异常诊断工具" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/tech-blog/2020/04/06/Java%E5%BC%82%E5%B8%B8%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/"
    >Java异常诊断工具</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/tech-blog/2020/04/06/Java%E5%BC%82%E5%B8%B8%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/" class="article-date">
  <time datetime="2020-04-06T12:33:24.000Z" itemprop="datePublished">2020-04-06</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/tech-blog/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="系统异常基本排查思路"><a href="#系统异常基本排查思路" class="headerlink" title="系统异常基本排查思路"></a>系统异常基本排查思路</h1><h2 id="CPU-使用率分析和异常排查"><a href="#CPU-使用率分析和异常排查" class="headerlink" title="CPU 使用率分析和异常排查"></a>CPU 使用率分析和异常排查</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h5 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a><strong>CPU时间片</strong></h5><p>CPU 时间片，即 CPU 分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片，即该进程允许运行的时间，使各个程序从表面上看是同时进行的。如果在时间片结束时进程还在运行，则 CPU 将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则 CPU 当即进行切换，而不会造成 CPU 资源浪费。</p>
<p>目前，计算机搭载的操作系统，如 Windows、Linux 等都是“多任务操作系统”，即可以“同时”执行多个任务，对于用户来说，就是可以“同时”执行多个应用程序，如“同时”看视屏和 QQ 聊天。事实上，这里的“同时”并不是真正意义上的同时。在此，以只有一个单核 CPU 的计算机为例进行说明，由于只有一个 CPU 内核，任何时刻都只能做一件事，那么，如何实现“多任务”呢？一个简明的策略就是引入时间片，每个程序轮流执行，这个时间片很短（Linux 系统为 5ms-800ms，Windows 系统与版本有关，但也是毫秒级），以至于用户无法感知，直观上如同多个程序同时在运行。</p>
<h5 id="CPU-使用率"><a href="#CPU-使用率" class="headerlink" title="CPU 使用率"></a><strong>CPU 使用率</strong></h5><p>CPU 使用率，即运行的程序占用 CPU 时间片的情况，</p>
<p>计算公式为：<strong>CPU 使用率 = CPU 时间片被程序使用的时间 / 总时间。</strong></p>
<p>目前，多任务操作系统对 CPU 都是分时间片使用的：<strong>比如 A 进程占用 10ms，然后 B 进程占用 30ms，然后空闲 60ms，再又是 A 进程占 10ms，B 进程占 30ms，空闲 60ms；如果在一段时间内都是如此，那么这段时间内 CPU 的占用率为 40%。</strong></p>
<p>大多数操作系统的 CPU 占用率分为用户态 CPU 使用率和系统态 CPU 使用率。用户态 CPU 使用率是指执行应用程序代码的时间占总 CPU 时间的百分比。相比而言，系统态 CPU 使用率是指应用执行操作系统调用的时间占总 CPU 时间的百分比。<strong>系统态的 CPU 使用率高意味着共享资源有竞争或者 I/O 设备之间有大量的交互。</strong></p>
<h2 id="查看CPU使用率"><a href="#查看CPU使用率" class="headerlink" title="查看CPU使用率"></a>查看CPU使用率</h2><h3 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h3><p>top 命令是 Linux 下常用的性能分析工具，能够实时显示系统 CPU，内存，Load，进程等信息，类似于 Windows 的任务管理器。如下所示，使用 top 命令执行结果：</p>
<p><strong>参数解释：</strong></p>
<ul>
<li>0.7% us：用户空间占用 CPU 百分比；</li>
<li>0.3% sy ：内核、内核进程占用 CPU 的比率；</li>
<li>0.0% ni ：如果一些用户进程修改过优先级，这里显示这些进程占用 CPU 时间的比率；</li>
<li>48.1% id： 空闲 CPU 百分比；</li>
<li>0.0% wa ：CPU 等待执行 I/O 操作的时间比率，该指标可以用来排查磁盘 I/O 的问题，通常结合 wa 和 id 判断；</li>
<li>0.0%hi：硬件 CPU 中断占用百分比；</li>
<li>0.0%si：软件 CPU 中断占用百分比；</li>
<li>50.9%st：物理机上其它虚拟机占用 CPU 的时间百分比；</li>
</ul>
<h2 id="查看CPU信息"><a href="#查看CPU信息" class="headerlink" title="查看CPU信息"></a>查看CPU信息</h2><p>命令：cat /proc/cpuinfo，执行结果如下，宿主机是 2 个核心。</p>
<p><strong>参数解释：</strong></p>
<ul>
<li>processor：系统中逻辑处理核的编号;</li>
<li>vendor_id：CPU 制造商;</li>
<li>cpu family：CPU 产品系列代号;</li>
<li>model：CPU 属于其系列中的哪一代的代号;</li>
<li>model name：CPU 属于的名字及其编号、标称主频;</li>
<li>stepping：CPU 属于制作更新版本;</li>
<li>cpu MHz：CPU 的实际使用主频;</li>
<li>cache size ：CPU 二级缓存大小;</li>
<li>physical id ：单个 CPU 的标号;</li>
<li>siblings ：单个 CPU 逻辑物理核数;</li>
<li>core id ：当前物理核在其所处 CPU 中的编号，这个编号不一定连续;</li>
<li>cpu cores ：该逻辑核所处 CPU 的物理核数;</li>
<li>apicid ：用来区分不同逻辑核的编号，系统中每个逻辑核的此编号必然不同，此编号不一定连续;</li>
<li>fpu ：是否具有浮点运算单元（Floating Point Unit）；</li>
<li>fpu_exception ：是否支持浮点计算异常；</li>
<li>cpuid level ：执行 cpuid 指令前，eax 寄存器中的值，根据不同的值 cpuid 指令会返回不同的内容；</li>
<li>wp ：表明当前 CPU 是否在内核态支持对用户空间的写保护（Write Protection）；</li>
<li>flags ：当前 CPU 支持的功能；</li>
<li>bogomips ：在系统内核启动时粗略测算的 CPU 速度（Million Instructions Per Second）；</li>
<li>clflush size ：每次刷新缓存的大小单位；</li>
<li>cache_alignment ：缓存地址对齐单位；</li>
<li>address sizes ：可访问地址空间位数；</li>
<li>power management ：对能源管理的支持。</li>
</ul>
<h2 id="定位CPU突然飙升的思路"><a href="#定位CPU突然飙升的思路" class="headerlink" title="定位CPU突然飙升的思路"></a>定位CPU突然飙升的思路</h2><h5 id="常见原因"><a href="#常见原因" class="headerlink" title="常见原因"></a><strong>常见原因</strong></h5><ul>
<li>宿主机 CPU“超卖”；</li>
<li>内存问题导致大量 Full GC ；</li>
<li>代码存在死循环。</li>
<li>线程开辟过多</li>
</ul>
<h5 id="宿主机-CPU-超卖"><a href="#宿主机-CPU-超卖" class="headerlink" title="宿主机 CPU 超卖"></a><strong>宿主机 CPU 超卖</strong></h5><p>执行 top 命令，结果如下图所示：</p>
<p><img src="java-dignostaic-1.jpg" alt="java-2"></p>
<p>top 命令输出的结果信息中，cpu st 的值，即宿主机 CPU 时间片分配给宿主机上其它虚拟机时间占比。如果 st 使用率较大，则 CPU 占用飙升是由于宿主机“超卖”导致，所谓“超卖”是一种通俗的说法，指的是宿主机 CPU 时间片分配给宿主机上其它虚拟机的比重过高（注意：截图中所示的占比并没有达到“超卖”的程度，仅作为示例）。</p>
<h5 id="内存问题，导致大量-Full-GC"><a href="#内存问题，导致大量-Full-GC" class="headerlink" title="内存问题，导致大量 Full GC"></a><strong>内存问题，导致大量 Full GC</strong></h5><p>对于 Java 应用而言，Full GC 是一个非常重要的指标，互联网企业通常都有自研的监控预警系统，用于监控 Full GC、堆内存、CPU 占用率等指标。如果企业有自研的监控系统，很容易确认是否为 Full GC 导致 CPU 飙高，如果没有这样的系统，那就需要工程师手动确认了，步骤如下：</p>
<p>Step1：通过 top 命令查看当前机器的 CPU 使用情况，如下截图（这里仅作为举例，CPU 使用率并没有飙升）。通过 top 命令输出的结果，可以看到 PID 为 9532 的 Java 进程占用 CPU 最多，可以作为怀疑对象，进一步“侦查”。需要说明的是，这里仅作为举例，截图中占用 CPU 最高的 Java 进程也就 4.0%，在真实的应用场景中，如果是频繁 Full GC 导致的 CPU 飙高，占用率要大得多。</p>
<p>Step2：通过 jstat 命令查看“有嫌疑”的 Java 进程的 GC 情况，常用的命令形式如下： jstat -gcutil 【PID】 1000 100，作用为：每 1000ms 打印一次 gc 统计情况，一共打印 100 次。</p>
<p><strong>参数解释：</strong></p>
<ul>
<li><p>S0 Survivor space 0 的利用率；</p>
</li>
<li><p>S1 Survivor space 1 的利用率；</p>
</li>
<li><p>E Eden space 的利用率；</p>
</li>
<li><p>O Old space 的利用率；</p>
</li>
<li><p>P Permanent space 的利用率；</p>
</li>
<li><p>YGC young gc 数量；</p>
</li>
<li><p>YGCT young gc 时间；</p>
</li>
<li><p>FGC Full gc 数量；</p>
</li>
<li><p>FGCT Full gc 时间；</p>
</li>
<li><p>GCT 所有的 gc 时间，(YGCT + FGCT)；</p>
<p>通过查看 Full GC 和 Young GC 次数，如果发现“嫌疑”进程存在频繁的 Full GC，我们可以进一步通过 Dump 应用的堆内存，对堆内存进行分析，定位异常代码。</p>
</li>
</ul>
<p>Step3：通过 Jmap 命令 Dump 有“嫌疑”的 Java 进程（应用程序）的堆快照和对象的统计信息。命令形式如下：</p>
<p><code>例1: jmap -histo 2927 &gt; a.txt 统计 PID 为 2927 的 Java 程序的对象统计信息</code></p>
<p><code>例2: jmap -dump:format=b,file=a.txt 统计 PID 为 2927 的 Java 程序的当前堆快照信息</code></p>
<p>Step4：通过 MAT（Memory Analysis Tools）工具对堆快照和对象的统计信息进行分析，定位问题，关于 MAT 工具的使用方法可以查看博客<a href="https://blog.csdn.net/jin_kwok/article/details/80326088。" target="_blank" rel="noopener">https://blog.csdn.net/jin_kwok/article/details/80326088。</a></p>
<h5 id="代码存在死循环"><a href="#代码存在死循环" class="headerlink" title="代码存在死循环"></a><strong>代码存在死循环</strong></h5><p>需要先定位到占用大量 CPU 时间片的 Java 线程，然后排查对应线程的代码定位原因，具体步骤如下：</p>
<p>Step1. 使用 top 命令找到 CPU 占用最高的线程（PID 为进程 ID），看一下是否为 Java 线程。</p>
<p>Step2. 确定有“嫌疑”的 Java 进程后，进一步查看该进程中 CPU 占比靠前的 Java 线程，其中的 PID 为子进程 ID，即 Java 线程 ID。命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -p 2066 -H，说明：-H 指显示线程，-p 是指定进程</span><br></pre></td></tr></table></figure>

<p>从打印的结果可以看出，“嫌疑”进程中 CPU 占比较高的 Java 线程有好几个，通常我们只能逐个排查。</p>
<p>Step3. 获得 Java 线程 ID 的十六进制值。通过 jstack 命令获取的线程堆栈信息中，线程 ID 是十六进制形式的，因此，为了便于搜索指定线程的相关信息，我们需要先对 top 命令获得的线程 ID 进行预处理，即转化为十六进制形式。命令如下：printf “%x” 3215，即打印十进制数 3215 转化为十六进制的值。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printf "%x\n" 3215</span><br><span class="line"></span><br><span class="line">c8f</span><br></pre></td></tr></table></figure>

<p>Step4. 通过 jstack 命令获取占用资源异常的线程栈。</p>
<p>可暂时保存到一个文件中查看 jstack 3215 &gt; jstack.3215.log，在生成的文件中，通过搜索线程ID的十六进制值找到对应的信息。为了快速定位问题，通常，我们会直接通过命令过滤出需要的信息，命令形式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 2066 | grep c8f</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li><p>jstack 的对象是 Java 进程的 PID，而不是 Java 线程的 PID；</p>
</li>
<li><p>尽量不要使用 jstack -F 命令，可能会导致应用的所有线程挂起。</p>
<p><strong>关于 jstack 命令的补充：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jstack 命令格式: jstack [ option ] pid</span><br><span class="line"></span><br><span class="line">option参数说明:</span><br><span class="line">-F jstack [-l] pid无法响应时，强制打印堆栈;</span><br><span class="line">-l l长列表. 打印关于锁的附加信息,例如属于java.util.concurrent的ownable synchronizers列表;</span><br><span class="line">-m 混合模式输出(包括java和本地c&#x2F;c++片段)堆栈;</span><br><span class="line"></span><br><span class="line">pid: java应用程序的进程号;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="系统负载（Load）分析和异常排查"><a href="#系统负载（Load）分析和异常排查" class="headerlink" title="系统负载（Load）分析和异常排查"></a>系统负载（Load）分析和异常排查</h3><h4 id="预备知识：系统负载"><a href="#预备知识：系统负载" class="headerlink" title="预备知识：系统负载"></a>预备知识：系统负载</h4><p>系统负载（Load）是指在一段时间内 CPU 正在处理以及等待 CPU 处理的进程数之和的统计信息，也就是 CPU 使用队列的长度的统计信息。</p>
<p>当 CPU 完全空闲的时候，平均负荷为 0；当 CPU 工作量饱和的时候，平均负荷为 1。举个例子，如果 CPU 每分钟最多处理 100 个进程，那么，系统负荷 0.2 就意味着 CPU 在这 1 分钟里只处理 20 个进程；系统负荷 1.0，意味着 CPU 在这 1 分钟里正好处理 100 个进程；系统负荷 1.7，意味着除了 CPU 正在处理的 100 个进程以外还有 70 个进程正排队等着 CPU 处理。</p>
<h5 id="系统负载（Load）与系统的繁忙程度"><a href="#系统负载（Load）与系统的繁忙程度" class="headerlink" title="系统负载（Load）与系统的繁忙程度"></a><strong>系统负载（Load）与系统的繁忙程度</strong></h5><p>在此，以<strong>单核 CPU</strong> 为例，解读系统负载（Load）与系统的繁忙程度的关系，注意关键词——单核 CPU。</p>
<ul>
<li>Load&lt;1：没有等待；</li>
<li>Load==1：系统已无额外的资源跑更多的进程了；</li>
<li>Load&gt;1：进程都堵着等待资源。</li>
</ul>
<p><strong>需要警惕的</strong></p>
<ul>
<li>Load &lt; 0.7 时：系统很闲，要考虑多部署一些服务；</li>
<li>0.7 &lt; Load &lt; 1 时：系统状态不错 ；</li>
<li>Load == 1 时：系统马上要处理不多来了，赶紧找一下原因；</li>
<li>Load &gt; 5 时：系统已经非常繁忙了。</li>
</ul>
<p><strong>不同 Load 值说明的问题</strong></p>
<ul>
<li>1 分钟 Load&gt;5，5 分钟 Load&lt;1，15 分钟 Load&lt;1</li>
</ul>
<p>短期内繁忙，中长期空闲，初步判断是一个抖动或者是拥塞前兆</p>
<ul>
<li>1 分钟 Load&gt;5，5 分钟 Load&gt;1，15 分钟 Load&lt;1</li>
</ul>
<p>短期内繁忙，中期内紧张，很可能是一个拥塞的开始</p>
<ul>
<li>1 分钟 Load&gt;5，5 分钟 Load&gt;5，15 分钟 Load&gt;5</li>
</ul>
<p>短中长期都繁忙，系统正在拥塞</p>
<ul>
<li>1 分钟 Load&lt;1，5 分钟 Load&gt;1，15 分钟 Load&gt;5</li>
</ul>
<p>短期内空闲，中长期繁忙，不用紧张，系统拥塞正在好转</p>
<h5 id="多核或者单核多处理器"><a href="#多核或者单核多处理器" class="headerlink" title="多核或者单核多处理器"></a><strong>多核或者单核多处理器</strong></h5><p><strong>单核多 CPU：</strong></p>
<p>如果计算机有 2 个单核 CPU，负载能力又是什么情况呢？2 个 CPU，意味着电脑的处理能力增加一倍，能够同时处理的进程数量也增加一倍。如果用大桥来类比，两个 CPU 就意味着大桥有两根车道了，通车能力翻倍了。所以，2 个 CPU 表明系统负荷可以达到 2.0，此时每个 CPU 都达到 100% 的工作量。推广开来，N 个单核 CPU 的计算机，可接受的系统负荷最大为：N*1.0。</p>
<p><strong>多核 CPU：</strong></p>
<p>目前，计算机所使用的 CPU 基本都是多核的，这类 CPU 被称为多核 CPU。在系统负载方面，多核 CPU 与多 CPU 效果类似，所以考虑系统负载时，必须考虑计算机有几个 CPU、每个 CPU 有几个核心。然后，把系统负载除以总的核心数，只要每个核心的负荷不超过 1.0，就表明计算机正常运行。对于具有 N 个 CPU，每个 CPU 具有 M 个核心的计算机，其系统负载最大为：N<em>M</em>1.0。</p>
<h5 id="CPU-使用率与负载（Load）的区别"><a href="#CPU-使用率与负载（Load）的区别" class="headerlink" title="CPU 使用率与负载（Load）的区别"></a><strong>CPU 使用率与负载（Load）的区别</strong></h5><p>这里要区别 CPU 负载和 CPU 利用率，它们是不同的两个概念。</p>
<p>CPU 利用率：显示的是程序在运行期间实时占用的 CPU 百分比，这是对一个时间段内 CPU 使用状况的统计，通过这个指标可以看出在某一个时间段内 CPU 被占用的情况， 如果被占用时间很高，那么就需要考虑 CPU 是否已经处于超负荷运作。</p>
<p>CPU 负载：显示的是在一段时间内 CPU 正在处理以及等待 CPU 处理的进程数之和的统计信息，也就是 CPU 使用队列的长度的统计信息。</p>
<p>简单理解，一个是 CPU 的实时使用情况，一个是 CPU 的当前以及未来一段时间的使用情况；</p>
<h4 id="查看系统负载"><a href="#查看系统负载" class="headerlink" title="查看系统负载"></a>查看系统负载</h4><h5 id="uptime-命令"><a href="#uptime-命令" class="headerlink" title="uptime 命令"></a><strong>uptime 命令</strong></h5><p><strong>关键参数解释：</strong> load average: 0.61，0.57，0.57 就是负载信息，分别表示 1 分钟、5 分钟、15 分钟内系统的平均负荷。</p>
<p><strong>其它参数解释：</strong> 11:46:19：系统当前时间 up 6 days, 18:54 ：系统开机到现在经过了 6 天</p>
<h5 id="w-命令"><a href="#w-命令" class="headerlink" title="w 命令"></a><strong>w 命令</strong></h5><p><strong>关键参数解释：</strong></p>
<p>load average: 0.74，0.61，0.59 就是负载信息，分别表示 1 分钟、5 分钟、15 分钟内系统的平均负荷。</p>
<p><strong>其它参数解释：</strong></p>
<ul>
<li><p>USER —登录的用户名；</p>
</li>
<li><p>TTY —登录后系统分配的终端号；</p>
</li>
<li><p>FROM—远程主机名，即从哪儿登录来的；</p>
</li>
<li><p>LOGIN@—何时登录；</p>
</li>
<li><p>IDLE—空闲了多长时间，表示用户闲置的时间。这是一个计时器，一旦用户执行任何操作，该计时器便会被重置；</p>
</li>
<li><p>JCPU—和该终端（tty）连接的所有进程占用的时间，这个时间里并不包括过去的后台作业时间，但却包括当前正在运行的后台作业所占用的时间；</p>
</li>
<li><p>PCPU—指当前进程（即在 WHAT 项中显示的进程）所占用的时间；</p>
</li>
<li><p>WHAT—当前正在运行进程的命令行。</p>
<h4 id="计算机正常负载范围"><a href="#计算机正常负载范围" class="headerlink" title="计算机正常负载范围"></a>计算机正常负载范围</h4><p>以单核 CPU 为例，经验法则是这样的：</p>
<ol>
<li><p>当系统负荷持续大于 0.7，你必须开始调查了，问题出在哪里，防止情况恶化；</p>
</li>
<li><p>当系统负荷持续大于 1.0，你必须动手寻找解决办法，把这个值降下来；</p>
</li>
<li><p>当系统负荷达到 5.0，就表明你的系统有很严重的问题，长时间没有响应，或者接近死机了。你不应该让系统达到这个值。</p>
<h4 id="CPU-使用率低而负载高"><a href="#CPU-使用率低而负载高" class="headerlink" title="CPU 使用率低而负载高"></a>CPU 使用率低而负载高</h4><p>主要原因是等待磁盘 I/O 的进程过多，导致进程队列长度过大，但是 CPU 运行的进程却很少，这样就导致负载过大，但 CPU 使用率低。</p>
<h5 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a><strong>常见场景</strong></h5><ul>
<li>磁盘读写请求过多就会导致大量 I/O 等待；</li>
<li>MySQL 中存在没有索引的语句或存在死锁；；</li>
<li>外接硬盘故障，常见有挂载了 NFS，但是 NFS Server 故障。</li>
</ul>
<h5 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a><strong>场景分析</strong></h5><p><strong>磁盘读写请求过多就会导致大量 I/O 等待</strong></p>
<p>CPU 的工作效率要高于磁盘，而进程在 CPU 上面运行需要访问磁盘文件，这个时候 CPU 会向内核发起调用文件的请求，让内核去磁盘取文件，这个时候会切换到其他进程或者空闲，这个任务就会转换为不可中断睡眠状态。当这种读写请求过多就会导致不可中断睡眠状态的进程过多，从而导致负载高，CPU 低的情况。</p>
<p><strong>MySQL 中存在没有索引的语句或存在死锁</strong></p>
<p>MySQL 的数据是存储在硬盘中，如果需进行 SQL 查询，要先把数据从磁盘加载到内存中。当在数据特别大的时候，如果执行的 SQL 语句没有索引，就会造成扫描表的行数过大导致 I/O 阻塞，或者是语句中存在死锁，也会造成 I/O 阻塞，从而导致不可中断睡眠进程过多，导致负载过大。</p>
<p><strong>外接硬盘故障，常见有挂载了 NFS，但是 NFS Server 故障</strong></p>
<p>假如系统挂载了外接硬盘，如 NFS 共享存储，经常会有大量的读写请求去访问 NFS 存储的文件，如果这个时候 NFS Server 故障，那么就会导致进程读写请求一直获取不到资源，从而进程一直是不可中断状态，造成负载很高。</p>
</li>
</ol>
</li>
</ul>
<h2 id="内存使用率异常"><a href="#内存使用率异常" class="headerlink" title="内存使用率异常"></a>内存使用率异常</h2><p>​         预备知识：内存</p>
<p>内存是计算机中重要的部件之一，它是与 CPU 进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大。一旦内存使用出现异常，对程序会产生重大影响。内存也被称为内存储器，其作用是用于暂时存放 CPU 中的运算数据，以及与硬盘等外部存储器交换的数据。</p>
<h5 id="物理内存"><a href="#物理内存" class="headerlink" title="物理内存"></a><strong>物理内存</strong></h5><p>物理内存指通过物理内存条而获得的内存空间，即随机存取存储器（Random Access Memory，RAM），是与 CPU 直接交换数据的内部存储器，也叫主存（内存）。</p>
<h5 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a><strong>虚拟内存</strong></h5><p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换（也就是说，当物理内存不足时，可能会借用磁盘空间来充当内存使用）。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如 RAM）的使用也更有效率。</p>
<h5 id="Swap-分区"><a href="#Swap-分区" class="headerlink" title="Swap 分区"></a><strong>Swap 分区</strong></h5><p>Swap 分区（即交换区）在系统的物理内存不够用的时候（没有了 buffers 和 cache 时），可以临时存放使用率不高的内存分页，把这一部分物理内存释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到 Swap 分区中，等到那些程序要运行时，再从 Swap 分区中恢复保存的数据到内存中。</p>
<p>对于线上的应用服务器，通常都不设置 swap，而是通过限定 jvm 内存小于物理内存的方式控制内存大小。</p>
<p><strong>参数解释：</strong></p>
<ul>
<li>Mem 是内存的使用情况；</li>
<li>-/+ buffers/cache 是物理内存的缓存统计情况；</li>
<li>Swap 是交换空间的使用情况。</li>
</ul>
<p><strong>列（Mem 行）：</strong></p>
<ul>
<li>total 4194304，表示物理内存总大小；</li>
<li>used 4172552，表示总计分配给缓存（包含 buffers 与cache ）使用的数量，其中可能部分缓存并未实际使用；</li>
<li>free 21752，表示未被分配的内存；</li>
<li>shared 0，共享内存，一般系统不会用到；</li>
<li>buffers 0，系统分配但未被使用的 buffers 数量；</li>
<li>cached 1773124，系统分配但未被使用的 cache 数量。</li>
</ul>
<p><strong>列（-/+ buffers/cache 行）：</strong></p>
<ul>
<li>Used 2399428，表示实际使用的 buffers 与cache 总量，也是实际使用的内存总量；</li>
<li>Free 1794876，未被使用的 buffers 与cache 和未被分配的内存之和，这就是系统当前实际可用内存。</li>
</ul>
<p><strong>数据间的关系：</strong></p>
<ul>
<li>used（-/+ buffers/cache） = used（Mem） – cached（Mem） – buffers（Mem）；</li>
<li>free（-/+ buffers/cache） = free（Mem） + cached （Mem）+ buffers（Mem）；</li>
<li>used（mem）为系统已分配内存大小；</li>
<li>free（-/+ buffers/cache）为系统实际可用内存大小；</li>
</ul>
<p>buffers 和 cache 的区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A buffer is something that has yet to be “written” to disk. </span><br><span class="line">A **cache** **is** something that has been “**read**” **from** the disk **and** **stored** **for** later use.</span><br></pre></td></tr></table></figure>

<h4 id="内存占用飙高及常见定位方法"><a href="#内存占用飙高及常见定位方法" class="headerlink" title="内存占用飙高及常见定位方法"></a>内存占用飙高及常见定位方法</h4><h5 id="常见原因-1"><a href="#常见原因-1" class="headerlink" title="常见原因"></a><strong>常见原因</strong></h5><ul>
<li>内存溢出</li>
<li>内存泄露</li>
<li>堆外内存使用不当</li>
</ul>
<h5 id="原因排查-内存溢出"><a href="#原因排查-内存溢出" class="headerlink" title="原因排查-内存溢出"></a><strong>原因排查-内存溢出</strong></h5><p>内存溢出：指程序运行过程中无法申请到足够的内存而导致的一种错误。内存溢出通常发生于 OLD 段或 Perm 段垃圾回收后，仍然无内存空间容纳新的 Java 对象的情况。</p>
<p><strong>1. 堆内存溢出（outOfMemoryError：java heap space）</strong></p>
<p>在 JVM 规范中，堆中的内存是用来生成对象实例和数组的。如果细分，堆内存还可以分为年轻代和年老代，年轻代包括一个 Eden 区和两个 Survivor 区。当生成新对象时，内存的申请过程如下：</p>
<ol>
<li>JVM 先尝试在 Eden 区分配新建对象所需的内存；</li>
<li>如果内存大小足够，申请结束，否则下一步；</li>
<li>JVM 启动 youngGC，试图将 Eden 区中不活跃的对象释放掉，释放后若 Eden 空间仍然不足以放入新对象，则试图将部分 Eden 中活跃对象放入 Survivor 区；</li>
<li>Survivor 区被用来作为 Eden 及 Old 的中间交换区域，当 Old 区空间足够时，Survivor 区的对象会被移到 Old 区，否则会被保留在 Survivor 区；</li>
<li>当 Old 区空间不够时，JVM 会在 Old 区进行 Full GC；</li>
<li>Full GC 后，若 Survivor 及 Old 区仍然无法存放从 Eden 复制过来的部分对象，导致 JVM 无法在 Eden 区为新对象创建内存区域，则出现”out of memory 错误”：outOfMemoryError：java heap space。</li>
</ol>
<p><strong>2. 方法区内存溢出（outOfMemoryError：permgem space）</strong></p>
<p>在 JVM 规范中，方法区主要存放的是类信息、常量、静态变量等。所以如果程序加载的类过多，或者使用反射、cglib 等这种动态代理生成类的技术，就可能导致该区发生内存溢出，一般该区发生内存溢出时的错误信息为：outOfMemoryError：permgem space。</p>
<p><strong>3. 线程栈溢出（java.lang.StackOverflowError）</strong></p>
<p>线程栈时线程独有的一块内存结构，所以线程栈发生问题必定是某个线程运行时产生的错误。一般线程栈溢出是由于递归太深或方法调用层级过多导致的。发生栈溢出的错误信息为：java.lang.StackOverflowError。</p>
<h5 id="原因排查-内存泄露"><a href="#原因排查-内存泄露" class="headerlink" title="原因排查-内存泄露"></a><strong>原因排查-内存泄露</strong></h5><p>内存泄露是指程序中动态分配内存给一些临时对象，代码段运行结束后，这些对象已经没有被使用，但由于 GC Roots 可达，没有被 GC 回收，始终占用内存。简单来说即被分配的对象无用但可达，这种问题一般是代码设计存在缺陷导致的。常用的定位步骤如下（结合例子说明）：</p>
<p>Step1. 使用 top 命令，查看占用内存较高的进程 ID</p>
<p>发现 PID 为 2544 的进程占用内存 58.2%，而且是一个 Java 进程，基本断定是程序问题。</p>
<p>Step2. 使用 jmap 查看内存情况，并分析是否存在内存泄露。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap 5442：查看java 堆（heap）使用情况</span><br><span class="line">jmap -histo 5442：查看堆内存(histogram)中的对象数量及大小 </span><br><span class="line">jmap -histo:live 5442：JVM会先触发gc，然后再统计信息</span><br><span class="line">jmap -**dump**:**format**&#x3D;b,file&#x3D;heapDump 5442：将内存使用的详细情况输出到文件</span><br></pre></td></tr></table></figure>

<p>得到堆 dump 文件后，使用 MAT（Memory Analyzer Tool）或者 Zprofile 进行对象分析。如果有大量对象在持续被引用，并没有被释放掉，那就产生了内存泄露。排查创建该对象的代码，进行修改。</p>
<p><strong>常见的代码内存泄露的原因有：</strong></p>
<ul>
<li>长生命周期的对象持有短生命周期对象的引用 ;</li>
<li>修改 hashse t中对象的参数值，且参数是计算哈希值的字段 ;</li>
<li>机器的连接数和关闭时间设置。</li>
</ul>
<h5 id="原因排查-堆外内存使用不当"><a href="#原因排查-堆外内存使用不当" class="headerlink" title="原因排查-堆外内存使用不当"></a><strong>原因排查-堆外内存使用不当</strong></h5><p><strong>什么是堆外内存</strong></p>
<p>和堆内内存相对应，堆外内存就是把内存对象分配在 Java 虚拟机的堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响。</p>
<p><strong>堆外内存的优点</strong></p>
<p>减少了垃圾回收 因为垃圾回收会暂停其他的工作； 加快了复制的速度 堆内在 flush 到远程时，会先复制到直接内存，然后再发送，而堆外内存相当于省略掉了复制这个步骤。</p>
<p><strong>堆外内存的缺点</strong></p>
<p>堆外内存的缺点就是内存难以控制，使用了堆外内存就间接失去了 JVM 管理内存的可行性，改由自己来管理，当发生内存溢出时排查起来非常困难。</p>
<p><strong>堆外内存使用场景</strong></p>
<p>NIO 引入了一种基于通道与缓冲区的 IO 方式，他可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 java.nio.DirectByteBuffer 对象作为这块堆外内存的引用进行操作。</p>
<p><strong>异常解决</strong></p>
<p>DirectMemory 容量可通过 -XX:MaxDirectMemorySize 指定，如果不指定，则默认与 Java 堆的最大值（-Xmx 指定）一样。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tech-blog/tags/%E7%B3%BB%E7%BB%9F%E5%BC%82%E5%B8%B8%E8%B0%83%E8%AF%95/" rel="tag">系统异常调试</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Dubbo-Introduction" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/tech-blog/2020/03/31/Dubbo-Introduction/"
    >Dubbo Introduction</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/tech-blog/2020/03/31/Dubbo-Introduction/" class="article-date">
  <time datetime="2020-03-31T04:13:57.000Z" itemprop="datePublished">2020-03-31</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="Dubbo介绍"><a href="#Dubbo介绍" class="headerlink" title="Dubbo介绍"></a>Dubbo介绍</h1>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Redis内存回收策略" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/tech-blog/2020/03/28/Redis%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/"
    >Redis内存回收策略</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/tech-blog/2020/03/28/Redis%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/" class="article-date">
  <time datetime="2020-03-28T14:36:20.000Z" itemprop="datePublished">2020-03-28</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="Redis内存回收策略"><a href="#Redis内存回收策略" class="headerlink" title="Redis内存回收策略"></a>Redis内存回收策略</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Redis内存回收机制主要体现在以下两个方面：</p>
<p>1.删除到达时间的键对象</p>
<p>2.内存使用达到maxmemory上限时触发内存溢出控制策略</p>
<h2 id="删除过期键对象"><a href="#删除过期键对象" class="headerlink" title="删除过期键对象"></a>删除过期键对象</h2><p>Redis所有的键都可以设置过期属性，内部保存在过期字典中。由于进程内保存了大量的键，维护每个键精准的过期删除机制会导致消耗大量的CPU，对于单线程的Redis来说成本过高，因此Redis采用<strong>惰性删除</strong>和<strong>定时任务删除</strong>机制实现过期键的内存回收。</p>
<p><strong>- 惰性删除</strong>：惰性删除用于当客户端读取带有超时属性的键时，如果已经超过键设置的过期时间，会执行删除操作并返回空，这种策略是出于节省CPU成本考虑，不需要单独维护TTL链表来处理过期键的删除。但是单独用这种方式存在内存泄露的问题，当过期键一直没有访问将无法得到及时删除，从而导致内存不能及时释放。正因为如此，Redis还提供另一种定时任务删除机制作为惰性删除的补充。<br> <strong>- 定时任务删除</strong>：Redis内部维护一个定时任务，默认每秒运行10次（通过配置hz控制）。定时任务中删除过期键逻辑采用了自适应算法，根据键的过期比例，使用快慢两种速率模式回收键。<br> 比如：</p>
<ol>
<li>定时任务在每个数据库空间随机检查20个键，当发现过期时删除对应的键。</li>
<li>如果超过检查数25%的键过期，循环执行回收逻辑直到不足25%或运行超时为止，慢模式下超时时间为25ms。</li>
<li>如果之前回收键逻辑超时，则在Redis触发内部事件之前再次以快模式运行回收过期键任务，快模式下超时时间为1ms且2s内只能运行1次。</li>
<li>快慢两种模式内部删除逻辑相同，只是执行的超时时间不同。</li>
</ol>
<h2 id="内存溢出控制策略"><a href="#内存溢出控制策略" class="headerlink" title="内存溢出控制策略"></a>内存溢出控制策略</h2><p>当Redis所用内存达到maxmemory上限时会触发相应的溢出控制策略。具体策略受maxmemory-policy参数控制，Redis支持6种策略，如下所示：</p>
<ol>
<li>noeviction：默认策略，当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。</li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。推荐使用，目前项目在用这种。</li>
<li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key。应该也没人用吧，你不删最少使用 Key，去随机删。</li>
<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。不推荐。</li>
<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key。依然不推荐。</li>
<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。不推荐。如果没有对应的键，则回退到noeviction策略。</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tech-blog/tags/Redis/" rel="tag">Redis</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/tech-blog/page/2/">2</a><a class="page-number" href="/tech-blog/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/tech-blog/page/5/">5</a><a class="extend next" rel="next" href="/tech-blog/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2019-2020
        Frank Zhou
      </li>
      <li>
        
          Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
      <aside class="sidebar">
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/tech-blog/"><img src="/tech-blog/images/ayer-side.svg" alt="Frank Zhou的博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tech-blog/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tech-blog/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tech-blog/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tech-blog/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tech-blog/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://shenyu-vip.lofter.com" target="_blank" rel="noopener">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tech-blog/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/tech-blog/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    
  </div>
</div>
      
<script src="/tech-blog/js/jquery-2.0.3.min.js"></script>


<script src="/tech-blog/js/jquery.justifiedGallery.min.js"></script>


<script src="/tech-blog/js/lazyload.min.js"></script>


<script src="/tech-blog/js/busuanzi-2.3.pure.min.js"></script>


<script src="/tech-blog/js/share.js"></script>



<script src="/tech-blog/fancybox/jquery.fancybox.min.js"></script>




<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['面朝大海，春暖花开','愿你一生努力，一生被爱','想要的都拥有，得不到的都释怀'],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>




<script>
  var ayerConfig = {
    mathjax: false
  }
</script>


<script src="/tech-blog/js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
  </div>
</body>

</html>